/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => RedPandaEditor
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// src/core/processor-engine.ts
var ProcessorEngine = class {
  constructor() {
    this.immediateProcessors = [];
    this.delayedProcessors = [];
    this.documentProcessors = [];
    this.viewportProcessors = [];
    this.keyHandlers = [];
    this.isProcessing = false;
    this.lastProcessedLineKey = "";
    this.lastProcessTime = 0;
    this.lastContentLength = 0;
    // Debug 控制（生產環境設為 false）
    this.debugMode = false;
  }
  registerProcessor(processor) {
    const processors = this.getProcessorsByType(processor.type);
    processors.push(processor);
    processors.sort((a, b) => a.priority - b.priority);
  }
  registerKeyHandler(handler) {
    this.keyHandlers.push(handler);
  }
  getProcessorsByType(type) {
    switch (type) {
      case "immediate":
        return this.immediateProcessors;
      case "delayed":
        return this.delayedProcessors;
      case "document":
        return this.documentProcessors;
      case "viewport":
        return this.viewportProcessors;
      default:
        throw new Error(`Unknown processor type: ${type}`);
    }
  }
  handleKeyEvent(event, editor) {
    for (const handler of this.keyHandlers) {
      if (handler.canHandle(event)) {
        const handled = handler.handle(event, editor);
        if (handled)
          return true;
      }
    }
    return false;
  }
  processDelayedChanges(editor) {
    if (this.isProcessing)
      return;
    const now = Date.now();
    const context = this.createContext(editor);
    const lineKey = `${context.cursor.line}:${context.line}`;
    const currentLength = context.fullContent.length;
    if (lineKey === this.lastProcessedLineKey || now - this.lastProcessTime < 50) {
      return;
    }
    const lengthDiff = Math.abs(currentLength - this.lastContentLength);
    const isLargeChange = lengthDiff > 100;
    const hasChineseSpacing = /[一-龯]\s+[一-龯]/.test(context.line);
    const isLongLineWithSpacing = context.line.length > 200 && hasChineseSpacing;
    if (this.debugMode) {
      console.log(`Content change detected: length diff=${lengthDiff}, isLarge=${isLargeChange}, hasChineseSpacing=${hasChineseSpacing}, longLine=${isLongLineWithSpacing}`);
    }
    this.isProcessing = true;
    try {
      this.processDocumentLevel(editor);
      if (isLargeChange || isLongLineWithSpacing) {
        this.processViewportLevel(editor);
        this.processDelayedLevel(editor);
      } else {
        this.processDelayedLevel(editor);
      }
      const newContext = this.createContext(editor);
      this.lastProcessedLineKey = `${newContext.cursor.line}:${newContext.line}`;
      this.lastProcessTime = now;
      this.lastContentLength = newContext.fullContent.length;
    } finally {
      this.isProcessing = false;
    }
  }
  createContext(editor) {
    const cursor = editor.getCursor();
    const line = editor.getLine(cursor.line);
    const fullContent = editor.getValue();
    return { editor, cursor, line, fullContent };
  }
  processDocumentLevel(editor) {
    let context = this.createContext(editor);
    for (const processor of this.documentProcessors) {
      if (processor.canHandle(context)) {
        const result = processor.process(context.fullContent, context);
        if (result !== context.fullContent) {
          const cursor = editor.getCursor();
          editor.setValue(result);
          editor.setCursor(cursor);
          console.log(`${processor.name}: Document processed`);
          context = this.createContext(editor);
        }
      }
    }
  }
  processDelayedLevel(editor) {
    let context = this.createContext(editor);
    if (this.debugMode) {
      console.log(`Processing delayed level with ${this.delayedProcessors.length} processors`);
    }
    for (const processor of this.delayedProcessors) {
      if (this.debugMode) {
        console.log(`Checking processor: ${processor.name} (priority: ${processor.priority})`);
      }
      if (processor.canHandle(context)) {
        if (this.debugMode) {
          console.log(`${processor.name} can handle, processing...`);
        }
        const result = processor.process(context.line, context);
        if (result !== context.line) {
          editor.setLine(context.cursor.line, result);
          if (this.debugMode) {
            console.log(`${processor.name}: "${context.line}" -> "${result}"`);
          }
          context = this.createContext(editor);
        }
      } else {
        if (this.debugMode) {
          console.log(`${processor.name} cannot handle this context`);
        }
      }
    }
  }
  processViewportLevel(editor) {
    const context = this.createContext(editor);
    const lineCount = editor.lineCount();
    const viewportRange = {
      from: Math.max(0, context.cursor.line - 50),
      to: Math.min(lineCount - 1, context.cursor.line + 50)
    };
    context.viewport = viewportRange;
    if (this.debugMode) {
      console.log(`Processing viewport: lines ${viewportRange.from}-${viewportRange.to}`);
    }
    for (let lineNum = viewportRange.from; lineNum <= viewportRange.to; lineNum++) {
      let currentLine = editor.getLine(lineNum);
      const originalLine = currentLine;
      const lineContext = {
        ...context,
        cursor: { line: lineNum, ch: context.cursor.ch },
        line: currentLine
      };
      for (const processor of this.viewportProcessors) {
        if (processor.canHandle({ ...lineContext, line: currentLine })) {
          const result = processor.process(currentLine, { ...lineContext, line: currentLine });
          if (result !== currentLine) {
            if (this.debugMode) {
              console.log(`${processor.name} (viewport): Line ${lineNum}: "${currentLine}" -> "${result}"`);
            }
            currentLine = result;
          }
        }
      }
      if (currentLine !== originalLine) {
        editor.setLine(lineNum, currentLine);
      }
    }
  }
};

// src/handlers/symbol-pairing-handler.ts
var SymbolPairingHandler = class {
  constructor() {
    this.name = "SymbolPairing";
    this.pairMap = {
      "\u300C": "\u300D",
      "\u300E": "\u300F",
      "\u300A": "\u300B",
      "\u3008": "\u3009",
      "\u3010": "\u3011"
    };
  }
  canHandle(event) {
    return event.key in this.pairMap;
  }
  handle(event, editor) {
    const key = event.key;
    const pair = this.pairMap[key];
    event.preventDefault();
    const selection = editor.getSelection();
    if (selection) {
      const cursor = editor.getCursor();
      editor.replaceSelection(key + selection + pair);
      editor.setCursor({
        line: cursor.line,
        ch: cursor.ch + selection.length + 2
      });
    } else {
      const cursor = editor.getCursor();
      editor.replaceRange(key + pair, cursor);
      editor.setCursor({
        line: cursor.line,
        ch: cursor.ch + 1
      });
    }
    return true;
  }
};

// src/handlers/symbol-deletion-handler.ts
var SymbolDeletionHandler = class {
  constructor() {
    this.name = "SymbolDeletion";
    this.pairMap = {
      "\u300C": "\u300D",
      "\u300E": "\u300F",
      "\u300A": "\u300B",
      "\u3008": "\u3009",
      "\u3010": "\u3011"
    };
  }
  canHandle(event) {
    return event.key === "Backspace";
  }
  handle(event, editor) {
    const cursor = editor.getCursor();
    const line = editor.getLine(cursor.line);
    if (cursor.ch > 0 && cursor.ch < line.length) {
      const charBefore = line[cursor.ch - 1];
      const charAfter = line[cursor.ch];
      if (charBefore in this.pairMap && this.pairMap[charBefore] === charAfter) {
        event.preventDefault();
        editor.replaceRange(
          "",
          { line: cursor.line, ch: cursor.ch - 1 },
          { line: cursor.line, ch: cursor.ch + 1 }
        );
        return true;
      }
    }
    return false;
  }
};

// src/processors/clipboard-processor.ts
var ClipboardProcessor = class {
  constructor() {
    this.name = "Clipboard";
    this.priority = 5;
    this.type = "document";
    // 全角轉半角映射表 (只轉換明確的程式/英文符號，完全避免中文標點)
    this.fullWidthToHalfWidth = /* @__PURE__ */ new Map([
      // 程式符號 - 明確應該是半角的
      ["\uFF08", "("],
      ["\uFF09", ")"],
      ["\uFF5B", "{"],
      ["\uFF5D", "}"],
      ["\uFF3B", "["],
      ["\uFF3D", "]"],
      // 英文專用符號 - 在程式碼和英文中應該是半角的
      ["\uFF02", '"'],
      ["\uFF07", "'"],
      ["\uFF40", "`"],
      ["\uFF20", "@"],
      ["\uFF03", "#"],
      ["\uFF05", "%"],
      ["\uFF3E", "^"],
      ["\uFF06", "&"],
      ["\uFF0A", "*"],
      ["\uFF3F", "_"],
      ["\uFF0B", "+"],
      ["\uFF1D", "="],
      ["\uFF5C", "|"],
      ["\uFF3C", "\\"],
      ["\uFF0F", "/"]
      // 完全避免轉換：！？－，。；：【】〈〉《》「」『』～
      // 這些符號在中文環境下應保持全角
    ]);
  }
  canHandle(context) {
    return this.hasFullWidthSymbols(context.fullContent) || this.hasExcessiveLineBreaks(context.fullContent);
  }
  process(text, context) {
    let result = text;
    result = this.convertFullWidthSymbols(result);
    result = this.cleanExcessiveLineBreaks(result);
    result = this.removeFormatInterference(result);
    return result;
  }
  /**
   * 檢查是否包含全角符號
   */
  hasFullWidthSymbols(text) {
    for (const fullWidth of this.fullWidthToHalfWidth.keys()) {
      if (text.includes(fullWidth))
        return true;
    }
    return false;
  }
  /**
   * 檢查是否有過多換行
   */
  hasExcessiveLineBreaks(text) {
    return /\n{3,}/.test(text);
  }
  /**
   * 轉換全角符號為半角
   */
  convertFullWidthSymbols(text) {
    let result = text;
    for (const [fullWidth, halfWidth] of this.fullWidthToHalfWidth) {
      result = result.split(fullWidth).join(halfWidth);
    }
    return result;
  }
  /**
   * 清理多餘換行，保持段落結構
   */
  cleanExcessiveLineBreaks(text) {
    return text.replace(/\n{3,}/g, "\n\n");
  }
  /**
   * 移除常見的格式干擾字符
   */
  removeFormatInterference(text) {
    return text.replace(/[\u200B-\u200D\uFEFF]/g, "").replace(/\u00AD/g, "").replace(/[""]/g, '"').replace(/['']/g, "'");
  }
};

// src/processors/document-processor.ts
var DocumentProcessor = class {
  constructor() {
    this.name = "Document";
    this.priority = 10;
    this.type = "document";
  }
  canHandle(context) {
    const lines = context.fullContent.split("\n");
    const currentLineNum = context.cursor.line;
    const startLine = Math.max(0, currentLineNum - 2);
    const endLine = Math.min(lines.length - 1, currentLineNum + 2);
    const localContent = lines.slice(startLine, endLine + 1).join("\n");
    return /([^\n\s])---([^\n\s])/.test(localContent) || /\.\.\.|⋅/.test(localContent) || this.needsHorizontalRuleSpacing(context);
  }
  process(text, context) {
    let result = text;
    const codeBlockRegex = /```[\s\S]*?```/g;
    const codeBlocks = [];
    result = result.replace(codeBlockRegex, (match) => {
      const placeholder = `__CODE_BLOCK_${codeBlocks.length}__`;
      codeBlocks.push(match);
      return placeholder;
    });
    result = result.replace(/\.\.\./g, "\u2026\u2026").replace(/⋅/g, "- ").replace(/([^\n\s])---([^\n\s])/g, "$1\n\n---\n\n$2");
    result = this.addHorizontalRuleSpacing(result);
    codeBlocks.forEach((block, index) => {
      result = result.replace(`__CODE_BLOCK_${index}__`, block);
    });
    return result;
  }
  /**
   * 檢查是否需要為分隔線添加間距
   */
  needsHorizontalRuleSpacing(context) {
    var _a;
    const lines = context.fullContent.split("\n");
    const currentLineNum = context.cursor.line;
    if (currentLineNum >= lines.length)
      return false;
    const currentLine = (_a = lines[currentLineNum]) == null ? void 0 : _a.trim();
    if (!this.isHorizontalRule(currentLine))
      return false;
    const prevLine = currentLineNum > 0 ? lines[currentLineNum - 1] : "";
    const nextLine = currentLineNum < lines.length - 1 ? lines[currentLineNum + 1] : "";
    return prevLine.trim() !== "" || nextLine.trim() !== "";
  }
  /**
   * 為分隔線添加適當的間距
   */
  addHorizontalRuleSpacing(content) {
    const lines = content.split("\n");
    const result = [];
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const trimmedLine = line.trim();
      if (this.isHorizontalRule(trimmedLine)) {
        const prevLine = i > 0 ? lines[i - 1] : "";
        const nextLine = i < lines.length - 1 ? lines[i + 1] : "";
        if (prevLine.trim() !== "" && result.length > 0 && result[result.length - 1].trim() !== "") {
          result.push("");
        }
        result.push(line);
        if (nextLine.trim() !== "") {
          result.push("");
        }
      } else {
        result.push(line);
      }
    }
    return result.join("\n");
  }
  /**
   * 檢查是否為水平分隔線
   */
  isHorizontalRule(line) {
    return /^[-*_]{3,}$/.test(line);
  }
};

// src/processors/paragraph-processor.ts
var ParagraphProcessor = class {
  constructor() {
    this.name = "Paragraph";
    this.priority = 70;
    this.type = "delayed";
  }
  canHandle(context) {
    return /^\s+/.test(context.line) || // 行首有空格/tab
    /\s+$/.test(context.line) || // 行尾有空格
    this.needsParagraphSpacing(context);
  }
  process(text, context) {
    let result = text;
    if (this.isOrderedListItem(result)) {
      result = this.normalizeListIndentation(result, false);
    } else if (this.isUnorderedListItem(result)) {
      result = this.normalizeListIndentation(result, true);
    } else if (!this.isMarkdownStructure(result.trim())) {
      result = result.replace(/^[\s\t]+/, "");
    }
    result = result.replace(/\s+$/, "");
    return result;
  }
  /**
   * 檢查是否需要段落間距處理
   */
  needsParagraphSpacing(context) {
    var _a;
    const lines = context.fullContent.split("\n");
    const currentLineNum = context.cursor.line;
    if (currentLineNum < lines.length - 1) {
      const currentLine = lines[currentLineNum].trim();
      const nextLine = (_a = lines[currentLineNum + 1]) == null ? void 0 : _a.trim();
      return this.isChineseParagraph(currentLine) && nextLine && nextLine.length > 0 && this.isChineseParagraph(nextLine);
    }
    return false;
  }
  /**
   * 檢查是否為中文段落（非Markdown結構）
   */
  isChineseParagraph(line) {
    if (!line || line.length === 0)
      return false;
    if (this.isMarkdownStructure(line))
      return false;
    return /[一-龯]/.test(line);
  }
  /**
   * 標準化列表項縮排，保持嵌套結構
   */
  normalizeListIndentation(line, isUnordered) {
    const indentMatch = line.match(/^[\s\t]*/);
    const originalIndent = (indentMatch == null ? void 0 : indentMatch[0]) || "";
    const indentLength = this.calculateIndentLength(originalIndent);
    const indentLevel = Math.floor(indentLength / 4);
    const minIndent = isUnordered ? 1 : 0;
    const finalIndentLevel = Math.max(minIndent, indentLevel);
    const normalizedIndent = "    ".repeat(finalIndentLevel);
    return line.replace(/^[\s\t]*/, normalizedIndent);
  }
  /**
   * 計算縮排長度（tab = 4空格）
   */
  calculateIndentLength(indent) {
    let length = 0;
    for (const char of indent) {
      if (char === "	") {
        length += 4;
      } else if (char === " ") {
        length += 1;
      }
    }
    return length;
  }
  /**
   * 檢查是否為有序列表項
   */
  isOrderedListItem(line) {
    const trimmed = line.trim();
    return /^\d+\.\s/.test(trimmed);
  }
  /**
   * 檢查是否為無序列表項
   */
  isUnorderedListItem(line) {
    const trimmed = line.trim();
    return /^[-*+]\s/.test(trimmed);
  }
  /**
   * 檢查是否為Markdown結構（標題、列表、引用等）
   */
  isMarkdownStructure(line) {
    const trimmed = line.trim();
    if (/^#{1,6}\s/.test(trimmed))
      return true;
    if (/^[-*+]\s/.test(trimmed))
      return true;
    if (/^\d+\.\s/.test(trimmed))
      return true;
    if (/^>\s/.test(trimmed))
      return true;
    if (/^```/.test(trimmed))
      return true;
    if (/^[-*_]{3,}$/.test(trimmed))
      return true;
    return false;
  }
};

// src/processors/paragraph-spacing-processor.ts
var ParagraphSpacingProcessor = class {
  constructor() {
    this.name = "ParagraphSpacing";
    this.priority = 75;
    this.type = "delayed";
  }
  canHandle(context) {
    const content = context.fullContent;
    return this.hasExcessiveBlankLines(content) || this.needsHeaderSpacing(content) || this.hasParagraphSpacingIssues(content);
  }
  process(text, context) {
    const lines = context.fullContent.split("\n");
    let processedLines = [...lines];
    processedLines = this.normalizeBlankLines(processedLines);
    processedLines = this.ensureHeaderSpacing(processedLines);
    processedLines = this.optimizeParagraphSpacing(processedLines);
    const newContent = processedLines.join("\n");
    const newLines = newContent.split("\n");
    return newLines[context.cursor.line] || text;
  }
  /**
   * 檢查是否有過多空白行
   */
  hasExcessiveBlankLines(content) {
    return /\n\s*\n\s*\n\s*\n/.test(content);
  }
  /**
   * 檢查是否需要標題間距調整
   */
  needsHeaderSpacing(content) {
    const lines = content.split("\n");
    for (let i = 1; i < lines.length; i++) {
      const currentLine = lines[i].trim();
      const prevLine = lines[i - 1].trim();
      if (this.isMarkdownHeader(currentLine) && prevLine.length > 0 && !this.isMarkdownHeader(prevLine) && i > 1) {
        return true;
      }
    }
    return false;
  }
  /**
   * 檢查段落間距問題
   */
  hasParagraphSpacingIssues(content) {
    var _a;
    const lines = content.split("\n");
    for (let i = 0; i < lines.length - 1; i++) {
      const currentLine = lines[i].trim();
      const nextLine = (_a = lines[i + 1]) == null ? void 0 : _a.trim();
      if (this.isChineseParagraph(currentLine) && this.isChineseParagraph(nextLine)) {
        return true;
      }
    }
    return false;
  }
  /**
   * 規範化空白行 - 3+ 連續空行縮減為 2 行
   */
  normalizeBlankLines(lines) {
    const result = [];
    let consecutiveEmptyCount = 0;
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const isEmptyLine = line.trim().length === 0;
      if (isEmptyLine) {
        consecutiveEmptyCount++;
        if (consecutiveEmptyCount <= 2) {
          result.push(line);
        }
      } else {
        consecutiveEmptyCount = 0;
        result.push(line);
      }
    }
    return result;
  }
  /**
   * 確保標題前後有適當間距
   */
  ensureHeaderSpacing(lines) {
    const result = [];
    for (let i = 0; i < lines.length; i++) {
      const currentLine = lines[i];
      const trimmedCurrent = currentLine.trim();
      if (this.isMarkdownHeader(trimmedCurrent)) {
        const prevLine = i > 0 ? lines[i - 1].trim() : "";
        const needsSpacingBefore = i > 0 && prevLine.length > 0 && !this.isMarkdownHeader(prevLine);
        if (needsSpacingBefore && result.length > 0 && result[result.length - 1].trim() !== "") {
          result.push("");
        }
      }
      result.push(currentLine);
    }
    return result;
  }
  /**
   * 優化段落間距
   *
   * 目前採用保守策略，不自動添加中文段落間空行
   * 避免過度格式化，保持用戶原有意圖
   */
  optimizeParagraphSpacing(lines) {
    return lines;
  }
  /**
   * 檢查是否為 Markdown 標題
   */
  isMarkdownHeader(line) {
    return /^#{1,6}\s/.test(line.trim());
  }
  /**
   * 檢查是否為中文段落
   */
  isChineseParagraph(line) {
    if (!line || line.length === 0)
      return false;
    if (this.isMarkdownStructure(line))
      return false;
    return /[一-龯]/.test(line);
  }
  /**
   * 檢查是否為 Markdown 結構
   */
  isMarkdownStructure(line) {
    const trimmed = line.trim();
    if (/^#{1,6}\s/.test(trimmed))
      return true;
    if (/^[-*+]\s/.test(trimmed))
      return true;
    if (/^\d+\.\s/.test(trimmed))
      return true;
    if (/^>\s/.test(trimmed))
      return true;
    if (/^```/.test(trimmed))
      return true;
    if (/^[-*_]{3,}$/.test(trimmed))
      return true;
    return false;
  }
};

// src/processors/viewport-paragraph-processor.ts
var ViewportParagraphProcessor = class {
  constructor() {
    this.name = "ViewportParagraph";
    this.priority = 70;
    this.type = "viewport";
  }
  canHandle(context) {
    return /^\s+/.test(context.line) || // 行首有空格/tab
    /\s+$/.test(context.line) || // 行尾有空格
    this.isChineseParagraph(context.line);
  }
  process(text, context) {
    let result = text;
    if (this.isOrderedListItem(result)) {
      result = this.normalizeListIndentation(result, false);
    } else if (this.isUnorderedListItem(result)) {
      result = this.normalizeListIndentation(result, true);
    } else if (!this.isMarkdownStructure(result.trim())) {
      result = result.replace(/^[\s\t]+/, "");
    }
    result = result.replace(/\s+$/, "");
    return result;
  }
  /**
   * 檢查是否為中文段落（非Markdown結構）
   */
  isChineseParagraph(line) {
    if (!line || line.length === 0)
      return false;
    if (this.isMarkdownStructure(line))
      return false;
    return /[一-龯]/.test(line);
  }
  /**
   * 標準化列表項縮排，保持嵌套結構
   */
  normalizeListIndentation(line, isUnordered) {
    const indentMatch = line.match(/^[\s\t]*/);
    const originalIndent = (indentMatch == null ? void 0 : indentMatch[0]) || "";
    const indentLength = this.calculateIndentLength(originalIndent);
    const indentLevel = Math.floor(indentLength / 4);
    const minIndent = isUnordered ? 1 : 0;
    const finalIndentLevel = Math.max(minIndent, indentLevel);
    const normalizedIndent = "    ".repeat(finalIndentLevel);
    return line.replace(/^[\s\t]*/, normalizedIndent);
  }
  /**
   * 計算縮排長度（tab = 4空格）
   */
  calculateIndentLength(indent) {
    let length = 0;
    for (const char of indent) {
      if (char === "	") {
        length += 4;
      } else if (char === " ") {
        length += 1;
      }
    }
    return length;
  }
  /**
   * 檢查是否為有序列表項
   */
  isOrderedListItem(line) {
    const trimmed = line.trim();
    return /^\d+\.\s/.test(trimmed);
  }
  /**
   * 檢查是否為無序列表項
   */
  isUnorderedListItem(line) {
    const trimmed = line.trim();
    return /^[-*+]\s/.test(trimmed);
  }
  /**
   * 檢查是否為Markdown結構（標題、列表、引用等）
   */
  isMarkdownStructure(line) {
    const trimmed = line.trim();
    if (/^#{1,6}\s/.test(trimmed))
      return true;
    if (/^[-*+]\s/.test(trimmed))
      return true;
    if (/^\d+\.\s/.test(trimmed))
      return true;
    if (/^>\s/.test(trimmed))
      return true;
    if (/^```/.test(trimmed))
      return true;
    if (/^[-*_]{3,}$/.test(trimmed))
      return true;
    return false;
  }
};

// src/processors/markdown-processor.ts
var MarkdownProcessor = class {
  constructor() {
    this.name = "Markdown";
    this.priority = 80;
    this.type = "delayed";
  }
  canHandle(context) {
    return /^(\s*)(#{1,6}[^\s#]|[-*+][^\s-*]|>+[^ >])/.test(context.line) && !this.isHorizontalRule(context.line);
  }
  process(text, context) {
    if (this.isHorizontalRule(text)) {
      return text;
    }
    return text.replace(/^(\s*)(#{1,6})([^\s#])/g, "$1$2 $3").replace(/^(\s*)(-|\*|\+)([^\s-*])/g, "$1$2 $3").replace(/^(>+)([^ >])/g, "$1 $2");
  }
  /**
   * 檢查是否為水平分隔線
   */
  isHorizontalRule(line) {
    const trimmed = line.trim();
    return /^[-*_]{3,}$/.test(trimmed);
  }
};

// src/processors/punctuation-processor.ts
var PunctuationProcessor = class {
  constructor() {
    this.name = "Punctuation";
    this.priority = 90;
    this.type = "delayed";
  }
  canHandle(context) {
    return /[一-龯]:/.test(context.line);
  }
  process(text, context) {
    return text.replace(/([一-龯]):/g, "$1\uFF1A");
  }
};

// src/processors/spacing-processor.ts
var SpacingProcessor = class {
  constructor() {
    this.name = "Spacing";
    this.priority = 100;
    this.type = "delayed";
  }
  canHandle(context) {
    const hasChineseEnglish = /[一-龯](?!\s)[a-zA-Z0-9]/.test(context.line);
    const hasEnglishChinese = /[a-zA-Z0-9](?!\s)[一-龯]/.test(context.line);
    const hasChineseSpacing = /[一-龯]\s+[一-龯]/.test(context.line);
    const canHandle = hasChineseEnglish || hasEnglishChinese || hasChineseSpacing;
    return canHandle;
  }
  process(text, context) {
    let result = text;
    const originalLength = text.length;
    result = result.replace(/([一-龯])(?!\s)([a-zA-Z0-9])/g, "$1 $2");
    result = result.replace(/([a-zA-Z0-9])(?!\s)([一-龯])/g, "$1 $2");
    let prevResult;
    let iterations = 0;
    do {
      prevResult = result;
      result = result.replace(/([一-龯])\s+([一-龯])/g, "$1$2");
      iterations++;
    } while (result !== prevResult && iterations < 20);
    return result;
  }
};

// src/processors/viewport-spacing-processor.ts
var ViewportSpacingProcessor = class {
  constructor() {
    this.name = "ViewportSpacing";
    this.priority = 100;
    this.type = "viewport";
  }
  canHandle(context) {
    return /[一-龯](?!\s)[a-zA-Z0-9]/.test(context.line) || /[a-zA-Z0-9](?!\s)[一-龯]/.test(context.line) || /[一-龯]\s+[一-龯]/.test(context.line);
  }
  process(text, context) {
    let result = text;
    result = result.replace(/([一-龯])(?!\s)([a-zA-Z0-9])/g, "$1 $2");
    result = result.replace(/([a-zA-Z0-9])(?!\s)([一-龯])/g, "$1 $2");
    let prevResult;
    let iterations = 0;
    do {
      prevResult = result;
      result = result.replace(/([一-龯])\s+([一-龯])/g, "$1$2");
      iterations++;
    } while (result !== prevResult && iterations < 20);
    return result;
  }
};

// src/processors/cleanup-processor.ts
var CleanupProcessor = class {
  constructor() {
    this.name = "Cleanup";
    this.priority = 110;
    this.type = "delayed";
  }
  canHandle(context) {
    return /\s{2,}|\s+$/.test(context.line) || this.isEmptyListItem(context.line);
  }
  process(text, context) {
    if (this.isEmptyListItem(text)) {
      return "";
    }
    if (this.isMarkdownListLine(text)) {
      return text.replace(/\s+$/g, "");
    }
    return text.replace(/\s{2,}/g, " ").replace(/\s+$/g, "");
  }
  /**
   * 檢查是否為空的列表項（只有符號沒有內容）
   */
  isEmptyListItem(text) {
    const trimmed = text.trim();
    if (/^[-*+]$/.test(trimmed))
      return true;
    if (/^\d+\.$/.test(trimmed))
      return true;
    return false;
  }
  /**
   * 檢查是否為 Markdown 列表行（需要保護縮排）
   */
  isMarkdownListLine(text) {
    const trimmed = text.trim();
    if (/^\d+\.\s/.test(trimmed))
      return true;
    if (/^[-*+]\s/.test(trimmed))
      return true;
    return false;
  }
};

// src/processors/viewport-cleanup-processor.ts
var ViewportCleanupProcessor = class {
  constructor() {
    this.name = "ViewportCleanup";
    this.priority = 110;
    this.type = "viewport";
  }
  canHandle(context) {
    return /\s{2,}|\s+$/.test(context.line) || this.isEmptyListItem(context.line);
  }
  process(text, context) {
    if (this.isEmptyListItem(text)) {
      return "";
    }
    if (this.isMarkdownListLine(text)) {
      return text.replace(/\s+$/g, "");
    }
    return text.replace(/\s{2,}/g, " ").replace(/\s+$/g, "");
  }
  /**
   * 檢查是否為空的列表項（只有符號沒有內容）
   */
  isEmptyListItem(text) {
    const trimmed = text.trim();
    if (/^[-*+]$/.test(trimmed))
      return true;
    if (/^\d+\.$/.test(trimmed))
      return true;
    return false;
  }
  /**
   * 檢查是否為 Markdown 列表行（需要保護縮排）
   */
  isMarkdownListLine(text) {
    const trimmed = text.trim();
    if (/^\d+\.\s/.test(trimmed))
      return true;
    if (/^[-*+]\s/.test(trimmed))
      return true;
    return false;
  }
};

// main.ts
var RedPandaEditor = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.timeout = null;
  }
  async onload() {
    console.info("Red Panda Editor: onload");
    this.engine = new ProcessorEngine();
    this.registerAllModules();
    this.registerDomEvent(document, "keydown", (event) => {
      var _a;
      const activeEditor = (_a = this.app.workspace.activeEditor) == null ? void 0 : _a.editor;
      if (!activeEditor)
        return;
      this.engine.handleKeyEvent(event, activeEditor);
    });
    this.registerEvent(
      this.app.workspace.on("editor-change", (editor) => {
        if (this.timeout) {
          clearTimeout(this.timeout);
        }
        this.timeout = setTimeout(() => {
          this.engine.processDelayedChanges(editor);
        }, 300);
      })
    );
  }
  onunload() {
    if (this.timeout) {
      clearTimeout(this.timeout);
    }
    console.info("Red Panda Editor: onunload");
  }
  registerAllModules() {
    this.engine.registerKeyHandler(new SymbolPairingHandler());
    this.engine.registerKeyHandler(new SymbolDeletionHandler());
    this.engine.registerProcessor(new ClipboardProcessor());
    this.engine.registerProcessor(new DocumentProcessor());
    this.engine.registerProcessor(new ParagraphProcessor());
    this.engine.registerProcessor(new ViewportParagraphProcessor());
    this.engine.registerProcessor(new ParagraphSpacingProcessor());
    this.engine.registerProcessor(new MarkdownProcessor());
    this.engine.registerProcessor(new PunctuationProcessor());
    this.engine.registerProcessor(new SpacingProcessor());
    this.engine.registerProcessor(new ViewportSpacingProcessor());
    this.engine.registerProcessor(new CleanupProcessor());
    this.engine.registerProcessor(new ViewportCleanupProcessor());
  }
};
